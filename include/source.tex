\chapter{Source Language}
\label{sec:source}

The inconsistency mentioned at the end of the previous chapter provides a
motivation to investigate sized types more carefully. This thesis takes a small
step in that direction by defining a calculus, λST, which transplants the sized
types of Agda into a very simple setting, the simply-typed lambda calculus.
(TODO words) In this chapter, we define λST and establish some syntactic
properties.


\section{Overview}
\label{sec:source:overview}

(TODO rewrite all that shit)

Before we dive into the technicalities of λST, let me give an overview of the
calculus by example, to show what it is capable of. Those who prefer their
exposition top-down may skip to Sec. \ref{sec:source:sizes} and return to this
section later.

λST, unlike Agda, does not feature subtyping (though I conjecture that this
could easily be added). To get around this limitation, we first define a
function that lifts a sized natural number to a larger size:
\begin{code}
  liftℕ : ∀ n < ⋆. ∀ m < n. ℕ m → ℕ n
  liftℕ ≔ Λ n < ⋆. Λ m < n. λ i : ℕ n.
          caseℕ[ℕ n] m i
            (zero n)
            (λ k < m. λ j : ℕ k. suc n k j)
\end{code}

\icode{liftℕ} already showcases most of the features of λST. Size variables are
introduced at the type level by size quantification \icode{∀ n < m. T} and at
the term level by the binder \icode{Λ n < m. t}. Each variable has an upper
bound, here \icode{m}, corresponding to the Agda type \icode{Size<~m}. However,
in λST we don't have \icode{∞~<~∞}, so in \icode{∀~n~<~∞.~T}, \icode{n} cannot
be instantiated with \icode{∞}. Since we do sometimes want to quantify over
every size including \icode{∞}, we introduce the size \icode{⋆} with
\icode{∞~<~⋆} so that we can form the type \icode{∀~n~<~⋆.~T}. This is
equivalent to Agda's \icode{(n~:~Size<~∞) → T}.

λST also features a type of sized natural numbers \icode{ℕ~n} with constructors
\icode{zero} and \icode{suc} and eliminator \icode{caseℕ[T]} (where \icode{T} is
an arbitrary type). The types of the constructors and eliminator are those one
would get if one were to define sized natural numbers in Agda:
\begin{code}
  zero     : ∀ n < ⋆. ℕ n
  suc      : ∀ n < ⋆. ∀ m < n. ℕ m → ℕ n
  caseℕ[T] : ∀ n < ⋆. ℕ n → T → (∀ m < n. ℕ m → T) → T
\end{code}
The \icode{caseℕ[T]} eliminator performs case analysis: If its first (non-size)
argument is zero, it returns the second argument; otherwise it applies the
function given as the third argument to the predecessor of the first argument.
Thus, \icode{liftℕ} is the identity function up to sizes.

Using \icode{liftℕ}, we define our first recursive function, \icode{half},
which divides its input by two (rounding down if the input is odd).
\begin{code}
  half : ∀ n < ⋆. ℕ n → ℕ n
  half ≔ Λ n < ⋆. fix[∀ m < ⋆. ℕ m → ℕ m]
    (Λ n < ⋆. λ rec ∶ (Λ m < n. ℕ m → ℕ m). λ (i : ℕ n).
      caseℕ
    )
    n
\end{code}

TODO better plus?
\begin{code}
  plus : ∀ n < ⋆. ℕ n → ℕ n → ℕ n
  plus ≔ Λ n < ⋆. fix[∀ m < ⋆. ℕ m → ℕ n → ℕ m]
    (Λ n < ⋆. λ rec : (Λ m < n. ℕ m → ℕ n → ℕ m).
      λ i : ℕ n. λ j : ℕ n. caseℕ[ℕ n] n i
        j
        (Λ m < n. λ i′ : ℕ m. suc n m (rec m i′ j)))
    n
\end{code}


\section{Sizes}
\label{sec:source:sizes}

In the following sections we define λST. All definitions and lemmas are
annotated with the name of the corresponding definition in the Agda
formalisation (if any). This section corresponds to the Agda module
\icode{Source.\allowbreak Size}.

\Def{Sizes} and \Def{size contexts} are defined by the grammar in Fig.
\ref{fig:syntax:sizes}. Size variables are de Bruijn indices; we write $v_x$ for
the x-th variable. (The examples in the previous sections instead used named
variables for clarity.)

\begin{figure}
  \begin{displaymath}
    \begin{array}{llcll}
      \text{size} & n, m, o & \bnfdef & v_x & \text{(size variable)} \\
      & & | & 0 & \text{(zero)} \\
      & & | & \ssuc{n} & \text{(successor)} \\
      & & | & ∞ & \text{(infinity)} \\
      & & | & ⋆ & \text{(star)} \\

      \text{size context} & Δ, Ω & \bnfdef & () & \text{(empty context)} \\
      & & | & \ctx{Δ}{n} & \text{(context extension)}
    \end{array}
  \end{displaymath}

  \caption{Syntax of sizes, size variables and size contexts}
  \label{fig:syntax:sizes}
\end{figure}

Our size grammar is essentially that of Agda (although of course Agda does not
have a separate grammatical category for sizes). We only add two sizes that
could easily be added to Agda as well: $0$ and $⋆$. Both are needed because λST,
unlike Agda, does not admit the rule $∞ < ∞$. For $⋆$ in particular we will have
$∞ < ⋆$, so a constraint of the form $x < ⋆$ corresponds to the Agda type
\icode{Size<~∞}. Contexts are telescopes of size bounds: In the context
$\ctx{Δ}{n}$, the zeroth variable $v_0$ ranges over sizes less than $n$ and $n$
may involve variables in $Δ$.

The typing judgments for sizes are mutually inductively generated by the rules
in Fig. \ref{fig:typing:sizes}. The judgment $Δ ⊢ v_x < n$ holds if $v_x$ is a
valid index into $Δ$ with declared bound $n$. The other two judgments, $Δ ⊢ n$
and $⊢ Δ$, ensure that sizes and contexts, respectively, are scope-safe. In the
definition of $Δ ⊢ v_x < n$, we use a weakened size $\wk(n)$, which is $n$ with
all variables incremented once. In the formalisation, scope safety is
already part of the definition of sizes/variables/contexts, so we do not need
separate typing judgments.

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ ⊢ v_x < n$} \\

    \inferrule{Δ ⊢ n}{\ctx{Δ}{n} ⊢ v_0 < n}

    \inferrule{Δ ⊢ v_x < n \\ Δ ⊢ m}{\ctx{Δ}{m} ⊢ v_{x + 1} < \wk(n)} \\

    \fbox{$Δ ⊢ n$} \\

    \inferrule{Δ ⊢ v_x < n}{Δ ⊢ v_x}

    \inferrule{⊢ Δ}{Δ ⊢ 0 \\ Δ ⊢ ∞ \\ Δ ⊢ ⋆}

    \inferrule{Δ ⊢ n}{Δ ⊢ \ssuc{n}} \\

    \fbox{$⊢ Δ$} \\

    \inferrule{ }{⊢ ()}

    \inferrule{Δ ⊢ n}{⊢ \ctx{Δ}{n}}

  \end{mathpar}

  \caption{Typing rules for sizes and size contexts}
  \label{fig:typing:sizes}
\end{figure}

For convenience, the judgments are defined such that $Δ ⊢ v_x < n$ implies $Δ ⊢
n$ and $Δ ⊢ n$ implies $⊢ Δ$, as is easily proved by induction on the respective
derivation. All other judgments we define below are structured similarly, so for
example $Δ ⊢ T$ (scope-safety of the type $T$) implies $⊢ Δ$ and $Δ; Γ ⊢ t ∶ T$
(well-typedness of a term $t$ of type $T$ in context $Γ$ and size context $Δ$)
implies $Δ ⊢ T$. We will henceforth use these lemmas implicitly.

Next, we define a syntactic comparison relation $Δ ⊢ n < m$ between sizes (in
the same context), which is inductively generated by the rules in Fig.
\ref{fig:typing:order}. The rules of $<$ are all supported by the intuition that
sizes roughly correspond to the natural numbers (TODO what about ∞/⋆?). The
first rule is not circular; its premise refers to the judgment $Δ ⊢ v_x < n$
from Fig. \ref{fig:typing:sizes}.

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ ⊢ n < m$} \\

    \inferrule{Δ ⊢ v_x < n}{Δ ⊢ v_x < n}

    \inferrule{Δ ⊢ n < ∞}{Δ ⊢ n < \ssuc{n}}

    \inferrule{⊢ Δ}{Δ ⊢ 0 < ∞}

    \inferrule{Δ ⊢ n < ∞}{Δ ⊢ \ssuc{n} < ∞}

    \inferrule{⊢ Δ}{Δ ⊢ ∞ < ⋆}

    \inferrule{Δ ⊢ n < m \\ Δ ⊢ m < o}{Δ ⊢ n < o}
  \end{mathpar}

  \caption{Size comparison}
  \label{fig:typing:order}
\end{figure}

Our $<$ differs from Agda's in two significant ways. First, Agda admits the rule
$∞ < ∞$ while we do not. This deviation is probably necessary considering that
$∞ < ∞$ seems to be the root cause of multiple inconsistencies in Agda (see Sec.
\ref{sec:background:sized}).

Second, we have $n < \ssuc{n}$ only if $n < ∞$ while Agda does not require this
premise. So in particular, we do not admit $∞ < \ssuc{∞}$ or $\ssuc{∞} <
\ssuc{\ssuc{∞}}$. Agda, on the other hand, does admit these rules but also
identifies $∞$ definitionally with $\ssuc{\dots\ssuc{∞}}$, which leads to
another proof of $∞ < ∞$.

In λST, we do not identify $∞$ with $\ssuc{∞}$. However, our definition of $<$
renders sizes of the form $\ssuc{\dots\ssuc{∞}}$ essentially useless: They are
not less than any other size and therefore cannot be used in most situations.
(The same goes for $\ssuc{\dots\ssuc{⋆}}$.) This means that we can get away with
leaving these sizes effectively uninterpreted in the model. We could
alternatively disallow them via the size typing rules, but that would add much
tedious code to the formalisation.

To finish the discussion of sizes, we state a technical lemma about weakening
that will be needed later:
\begin{lemma}[Weakening preserves typing and $<$]
  \label{lem:wk-preservation}
  If $Δ ⊢ n$ and $Δ ⊢ m$ then $\ctx{Δ}{m} ⊢ \wk(n)$. If $Δ ⊢ o$ and $Δ ⊢ n < m$
  then $\ctx{Δ}{o} ⊢ \wk(n) < \wk(m)$.
\end{lemma}


\section{Size Substitutions}
\label{sec:source:sub}

Having size variables, we must say how to substitute for them. λST uses implicit
substitutions, so substitutions are not part of the calculus' grammar. Despite
this, we define a universe of simultaneous substitutions between given size
contexts instead of just saying what it means to substitute for a variable.
(TODO the two clauses are in the wrong order.) This will be helpful when we get
to the model, where substitutions will correspond to morphisms between (the
interpretations of) size contexts. Size substitutions and their properties are
formalised in \icode{Source.\allowbreak Size.\allowbreak
  Substitution.\allowbreak Canonical}.

A \Def{size substitution} is a list of sizes. We write $()$ for the empty
substitution and $\ssub{σ}{n}$ for the extension of $σ$ with a size $n$. The
application of a substitution to a size, $\sub{n}{σ}$, is defined by recursion
on $n$:
\begin{Align*}
  \sub{v_x}{()} &≔& v_x \\
  \sub{v_0}{\ssub{σ}{n}} &≔& n \\
  \sub{(v_{x + 1})}{\ssub{σ}{n}} &≔& \sub{v_x}{σ} \\
  \sub{0}{σ} &≔& 0 \\
  \sub{(\ssuc{n})}{σ} & ≔ & \ssuc{\sub{n}{σ}} \\
  \sub{∞}{σ} &≔& ∞ \\
  \sub{⋆}{σ} &≔& ⋆ \\
\end{Align*}
Fig. \ref{fig:typing:ssub} gives the typing rules for size substitutions.
The first equation above is impossible if $σ$ and $n$ are well-typed.

\begin{figure}
  \begin{mathpar}
    \fbox{$σ ∶ Δ ⇒ Ω$} \\

    \inferrule{⊢ Δ}{() ∶ Δ ⇒ ()} \\

    \inferrule{σ ∶ Δ ⇒ Ω \\ Δ ⊢ n \\ Ω ⊢ m \\ Δ ⊢ n < \sub{m}{σ}}{\ssub{σ}{n} ∶ Δ ⇒ \ctx{Ω}{m}}
  \end{mathpar}

  \caption{Typing rules for size substitutions}
  \label{fig:typing:ssub}
\end{figure}

The typing rules ensure that if we have $σ ∶ Δ ⇒ Ω$ then $σ$ maps every variable
$v_x$ in $Ω$ to a size $n$ such that $n$ contains only variables in $Δ$ and $n$
respects the bound declared for $v_x$ in $Ω$. Due to these properties,
well-typed substitutions are well-behaved with regards to typing and size
comparison:

\begin{lemma}[Size substitutions preserve typing and $<$]
  \label{lem:sub-preservation}
  If $σ ∶ Δ ⇒ Ω$ and $Ω ⊢ n$ then $Δ ⊢ \sub{n}{σ}$. If $σ ∶ Δ ⇒ Ω$ and $Ω ⊢ n <
  m$ then $Δ ⊢ \sub{n}{σ} < \sub{m}{σ}$.
\end{lemma}

\begin{proof}
  By induction on the derivation of $Ω ⊢ n$. In the proof of $Δ ⊢ \sub{n}{σ} <
  \sub{m}{σ}$, we use the lemma $\sub{\wk(m)}{\ssub{σ}{n}} = \sub{m}{σ}$, which
  is proved by a simple induction.
\end{proof}

Note that we write $σ ∶ Δ ⇒ Ω$ even though substitution with $σ$ transforms an
object in $Ω$ into an object in $Δ$. This notation is inspired by the model,
where $Δ$ and $Ω$ will be particular types and $σ$ a function between them.

Having constructed a universe of substitutions, we now define some particular
substitutions in this universe which we will use later. We could also have
axiomatised these substitutions directly, but that would have made the
substitution operation and any proofs about it more complex, and we would also
have had to axiomatise some equations between substitutions instead of proving
them as a lemma. Our design leads to some subtle problems in the formalisation;
see Sec. \ref{sec:formalisation:sub} for details and a workaround.

We define the following well-typed substitutions (assuming a well-typed
size $Δ ⊢ m$ and substitutions $σ ∶ Δ ⇒ Ω$, $τ ∶ Ω ⇒ Ω′$):
\begin{itemize}
  \item The \Def{weakening} of $σ$ is
    \begin{Align*}
      \multicolumn{3}{l}{\Weaken(σ) ∶ \ctx{Δ}{m} ⇒ Ω} \\
      \Weaken(()) &≔& () \\
      \Weaken(\ssub{σ}{n}) &≔& \ssub{\Weaken(σ)}{\wk(n)}.
    \end{Align*}
  \item The \Def{lifting} of $σ$ is
    \begin{gather*}
      \Lift(σ) ∶ \ctx{Δ}{n[σ]} ⇒ \ctx{Ω}{n} \\
      \Lift(σ) ≔ \ssub{\Weaken(σ)}{v_0}.
    \end{gather*}
   \item The \Def{identity substitution} $\Id_Δ$ is
     \begin{Align*}
       \multicolumn{3}{l}{\Id ∶ Δ ⇒ Δ} \\
       \Id_{()} &≔& () \\
       \Id_{\ctx{Δ}{n}} &≔& \Lift(\Id_Δ).
     \end{Align*}
   \item The \Def{forward composition} of $σ$ and $τ$ is
     \begin{Align*}
       \multicolumn{3}{l}{σ \fcomp τ ∶ Δ ⇒ Ω′} \\
       σ \fcomp () &≔& () \\
       σ \fcomp (\ssub{τ}{n}) &≔& \ssub{(σ \fcomp τ)}{\sub{n}{σ}}
     \end{Align*}
   \item The \Def{weakening substitution} is
     \begin{gather*}
       \Wk ∶ \ctx{Δ}{m} ⇒ Δ \\
       \Wk ≔ \Weaken(\Id).
     \end{gather*}
   \item Assuming that $Δ ⊢ n < m$, the \Def{filling substitution} of $n$ is
     \begin{gather*}
       \Fill(n) ∶ Δ ⇒ \ctx{Δ}{m} \\
       \Fill(n) ≔ \ssub{\Id_Δ}{n}.
     \end{gather*}
   \item The \Def{skipping substitution} is
     \begin{gather*}
       \Skip ∶ \ctx{\ctx{Δ}{m}}{v_0} ⇒ \ctx{Δ}{m} \\
       \Skip ≔ \ssub{\Weaken(\Wk)}{v_0}.
     \end{gather*}
\end{itemize}

The first five of these substitutions are standard. The filling substitution
$\Fill(n)$ instantiates the zeroth variable with $n$ while leaving everything
else as it is. The skipping substitution is a bit more specific; it is perhaps
best understood by switching to explicit variables for a moment: Given a size
$n$ in the context $Δ,\, x < m$, $\sub{n}{\Skip}$ lives in the context $Δ,\, x <
m, y < x$ and all occurrences of $x$ in $n$ are replaced by $y$. In this sense,
$\sub{n}{\Skip}$ \enquote*{skips} the variable $x$.

(TODO rewrite the rest of this section)

A weakened substitution $\Weaken(σ)$ is the same as $σ$, only with each variable
incremented once. The following lemma makes this precise.

\begin{lemma}[Application of $\Weaken$ (\icode{sub-Weaken})]
  For all $n$ and $σ$, $\sub{n}{\Weaken(σ)} = \wk(\sub{n}{σ})$.
\end{lemma}

When applied, the lifted substitution $\Lift(σ)$ maps $v_0$ to $v_0$ and
$v_{x+1}$ to $\sub{v_x}{σ}$. In this sense, it is $σ$ \enquote*{lifted} to a
larger context.

\begin{lemma}[Application of $\Id$ (\icode{sub-Id})]
  For any size $n$, $\sub{n}{\Id} = n$.
\end{lemma}

\begin{lemma}[Application of $σ \fcomp τ$ (\icode{sub->>})]
  For any substitutions $σ$, $τ$ and size $n$, $\sub{n}{σ \fcomp τ} = \sub{\sub{n}{τ}}{σ}$.
\end{lemma}

Well-typed substitutions are the arrows of a category whose objects are size
contexts, with identity arrows $\Id_Δ$ and (flipped) composition $\fcomp$. It is
easy to verify that $\fcomp$ is associative with identity $\Id$. (The proof
relies on Lemma (TODO ref) below.)

When applied, $\Fill(n)$ replaces the zeroth variable with $n$ and leaves all other
variables as they are.

\begin{definition}[Skipping substitution (\icode{Skip, Skip⊢})]
  $\Skip(n)$ is the substitution
  \begin{displaymath}
    \Skip(n) ≔ \ssub{\Weaken(\Wk)}{v_0}.
  \end{displaymath}
  Assuming that $Δ ⊢ n$, we have $\Skip ∶ \ctx{\ctx{Δ}{n}}{v_0} ⇒ \ctx{Δ}{n}$.
\end{definition}

(TODO what is the meaning of $\Skip(n)$?)

(TODO lemmas about how the substitutions interact.)

\section{Types}
\label{sec:source:types}

We move on to the type-level expressions of λST. This section is formalised in
\icode{Source.\allowbreak Type}.

The types and contexts of λST are generated by the grammar in Fig.
\ref{fig:syntax:types}. Their typing rules appear in Fig.
\ref{fig:typing:types}.

\begin{figure}
  \begin{displaymath}
    \begin{array}{llcll}
      \text{type} & T, U, V & \bnfdef & \Nat{n} & \text{(sized naturals)} \\
      & & | & \Stream{n} & \text{(sized streams)} \\
      & & | & T → U & \text{(function space)} \\
      & & | & \All{n}{T} & \text{(size quantification)} \\

      \text{context} & Γ, Ψ & \bnfdef & () & \text{(empty context)} \\
      & & | & \Ctx{Γ}{T} \\
    \end{array}
  \end{displaymath}

  \caption{Syntax of types and contexts}
  \label{fig:syntax:types}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ ⊢ T$} \\

    \inferrule{Δ ⊢ n}{Δ ⊢ \Nat{n} \\ Δ ⊢ \Stream{n}}

    \inferrule{Δ ⊢ T \\ Δ ⊢ U}{Δ ⊢ T → U}

    \inferrule{\ctx{Δ}{n} ⊢ T}{Δ ⊢ \All{n}{T}}
    \\

    \fbox{$Δ ⊢ Γ$} \\

    \inferrule{⊢ Δ}{Δ ⊢ ()}

    \inferrule{Δ ⊢ Γ \\ Δ ⊢ T}{Δ ⊢ \ctx{Δ}{T}}
  \end{mathpar}

  \caption{Validity of types and contexts}
  \label{fig:typing:types}
\end{figure}

λST features two base types: $\Nat{n}$, the type of sized natural numbers, and
$\Stream{n}$, the type of sized streams. We will discuss these in more detail
when we get to the terms of λST. As for type formers, λST has a non-dependent
function space $T → U$ and size quantification $\All{n}{T}$. Note that $n$ is
not a variable, as the notation may suggest, but the bound of the zeroth de
Bruijn index in $T$. Size quantification works essentially like quantification
in System F if we think of the bound $n$ as the \enquote*{type} of a size
variable. Contexts lists of types.

The typing rules for types and contexts ensure scope-safety relative to some
size context. In the formalisation, scope safety is again built into the data
types representing types and contexts, so there are no separate typing
judgments.

Since types can contain size variables, we define \Def{size substitution in
  types}, written $\sub{T}{σ}$, by recursion over the type:
\begin{Align*}
  \sub{(\Nat{n})}{σ} &≔& \Nat{\sub{n}{σ}} \\
  \sub{(\Stream{n})}{σ} &≔& \Stream{\sub{n}{σ}} \\
  \sub{(T → U)}{σ} &≔& \sub{T}{σ} → \sub{U}{σ} \\
  \sub{(\All{n}{T})}{σ} &≔& \All{\sub{n}{σ}}{\sub{T}{\Lift(σ)}}
\end{Align*}
Substitution in contexts $\sub{Γ}{σ}$ is the pointwise extension of substitution
in types.

The only interesting case of the above definition is that for size
quantification. Here, we must recurse with $\Lift(σ)$ rather than $σ$ because
$T$ is a type in $\ctx{Δ}{n}$ while $\All{n}{T}$ is a type in $Δ$.


\section{Terms}
\label{sec:source:terms}

In this section, we define the terms of λST and their typing rules. The
corresponding module in the formalisation is \icode{Source.\allowbreak Term}.

The terms of λST are generated by the grammar in Fig. \ref{fig:syntax:terms}.
Term variables, like size variables, are de Bruijn indices.

\begin{figure}
  \begin{displaymath}
    \begin{array}{llcll}
      \text{term} & t, u, v & \bnfdef & v_x & \text{(variable)} \\
      & & | & \lam{T}{t} & \text{(abstraction)} \\
      & & | & \app{t}{u} & \text{(application)} \\
      & & | & \slam{n}{t} & \text{(size abstraction)} \\
      & & | & \sapp{t}{n} & \text{(size application)} \\
      & & | & \zero{n} & \text{(zero)} \\
      & & | & \suc{n}{m}{t} & \text{(successor)} \\
      & & | & \case{T}{n}{t}{u}{v} & \text{(case analysis for $\Nat{n}$)} \\
      & & | & \cons{t}{n}{u} & \text{(stream construction)} \\
      & & | & \head{n}{t} & \text{(stream head)} \\
      & & | & \tail{n}{t}{m} & \text{(stream tail)} \\
      & & | & \fix{T}{t}{n} & \text{(sized fixpoint)}
    \end{array}
  \end{displaymath}

  \caption{Syntax of terms}
  \label{fig:syntax:terms}
\end{figure}

The first three term constructions are those of the simply-typed lambda
calculus: variables, abstraction and application. The next two are size
abstraction and size application, which respectively introduce and eliminate a
size quantification. They are analogous to System F's type abstraction and type
application.

The other terms are conceptually constants, though we introduce them as term
formers to simplify the model (and particularly the formalisation). If they were
constants, they would have the following types (with explicit variables for
convenience):
\begin{Align*}
  \mathrm{zero} &∶& \AllE{x}{⋆}{\Nat{x}} \\
  \mathrm{suc} &∶& \AllE{x}{⋆}{\AllE{y}{x}{\Nat{y} → \Nat{x}}} \\
  \mathrm{caseNat}[T] &∶& \AllE{x}{⋆}{\Nat{x} → T → (\AllE{y}{x}{T}) → T} \\
  \mathrm{cons} &∶& \Nat{∞} → \AllE{x}{⋆}{(\AllE{y}{x}{\Stream{y}}) → \Stream{x}} \\
  \mathrm{head} &:& \AllE{x}{⋆}{\Stream{x} → \Nat{∞}} \\
  \mathrm{tail} &:& \AllE{x}{⋆}{\Stream{x} → \AllE{y}{x}{\Stream{y}}} \\
  \mathrm{fix}[T(∙)] &:& (\AllE{x}{⋆}{(\AllE{y}{x}{T(y)}) → T(x)}) → \AllE{x}{⋆}{T(x)}
\end{Align*}
The terms $\mathrm{zero}$ and $\mathrm{suc}$ serve as constructors of $\Nat{n}$.
The type $\Nat{n}$ may be thought of as the set of natural numbers less than or
equal to $n$. As such, 0 is a member of $\Nat{n}$ for any $n$, as the type of
$\mathrm{zero}$ indicates. Similarly, if we have a natural number $≤ n$, its
successor is $≤ m$ for any $m > n$, which justifies the type of $\mathrm{suc}$.
$\mathrm{caseNat}[T]$ is an eliminator for $\Nat{n}$ (into some arbitrary type
$T$) which performs case analysis on its first non-size argument. In the zero
case, it returns its second argument; in the successor case, it returns the
result of applying the function given as the third argument to the predecessor
of the given natural. That predecessor, of course, has some smaller size $m <
n$.

For $\Stream{n}$, the size $n$ has the opposite meaning: Where $\Nat{n}$
contains naturals up to \emph{at most} $n$, $\Stream{n}$ is roughly speaking the
type of lists of naturals with \emph{at least} $n$ elements. This is because
$\Nat{n}$ is an inductive type while $\Stream{n}$ is coinductive. More
precisely, a value of $\Stream{n}$ is a function which maps any natural number
$m ≤ n$ to a natural number. $\Stream{∞}$ is then the type of functions $ℕ → ℕ$,
which is isomorphic to the coinductively defined type of infinite streams of
naturals. The constructor $\mathrm{cons}$ and the destructors $\mathrm{head}$
and $\mathrm{tail}$ reflect this understanding. The first destructor,
$\mathrm{head}$, extracts the element at index 0 from a $\Stream{n}$ (which
always exists since $0 ≤ n$). The second destructor, $\mathrm{tail}$, when given
a $\Stream{n}$, returns its tail, which has one less element and is therefore an
element of $\Stream{m}$ for any $m < n$. The constructor $\mathrm{cons}$ takes a
function which generates a $\Stream{m}$ for any $m < n$ and prepends an element,
returning a bigger $\Stream{n}$.\footnote{Another plausible type for
  $\mathrm{cons}$ would be $\Nat{∞} → \AllE{x}{⋆}{\AllE{y}{x}{\Stream{y} →
      \Stream{x}}}$, replacing the family of streams with a single stream (TODO
  unclear?). I choose not to use this simpler type because if we define sized
  streams in Agda, $\mathrm{cons}$ has the type given in the main text.}

The final term, $\mathrm{fix}[T]$, is at the heart of λST: It is a size-based
fixpoint combinator that allows us both to recurse over sized natural numbers
and to build sized streams corecursively. It is parameterised by a type $T$ with
one free size variable or \enquote*{hole}, as the notation $T(∙)$ suggests.
The type of $\mathrm{fix}[T]$ is essentially the principle of induction over
sizes: If from an object of size $m$ we can construct an object of size $n > m$,
then we can construct an object of any size.

The typing rules of λST terms, which appear in Fig. \ref{fig:typing:terms},
follow directly from the previous discussion, only with constants
replaced by equivalent term formers and explicit variables replaced by de Bruijn
indices and size substitutions.

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ; Γ ⊢ t ∶ T$} \\

    \inferrule{Δ ⊢ Γ \\ Δ ⊢ T}{Δ; \Ctx{Γ}{T} ⊢ v_0 ∶ T}

    \inferrule{Δ; Γ ⊢ v_x ∶ T \\ Δ ⊢ U}{Δ; \Ctx{Γ}{U} ⊢ v_{x + 1} ∶ T}

    \inferrule{Δ; \Ctx{Γ}{T} ⊢ t ∶ U}{Δ; Γ ⊢ \lam{T}{t} ∶ T → U}

    \inferrule{Δ; Γ ⊢ t ∶ T → U \\ Δ; Γ ⊢ u ∶ T}{Δ; Γ ⊢ \app{t}{u} ∶ U}

    \inferrule{\ctx{Δ}{n}; \sub{Γ}{\Wk} ⊢ t ∶ T \\ Δ ⊢ Γ}
      {Δ; Γ ⊢ \slam{n}{t} ∶ \All{n}{T}}

    \inferrule{Δ; Γ ⊢ t ∶ \All{n}{T} \\ Δ ⊢ m < n}
      {Δ; Γ ⊢ \sapp{t}{m} ∶ \sub{T}{\Fill(m)}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ ⊢ Γ}{Δ; Γ ⊢ \zero{n} ∶ \Nat{n}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ ⊢ m < n \\ Δ; Γ ⊢ i ∶ \Nat{m}}
      {Δ; Γ ⊢ \suc{n}{m}{i} ∶ \Nat{n}}

    \inferrule{Δ ⊢ T \\ Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ i ∶ \Nat{n} \\ Δ; Γ ⊢ z ∶ T \\
      Δ; Γ ⊢ s ∶ \All{n}{\Nat{v_0} → \sub{T}{\Wk}}}
      {Δ; Γ ⊢ \case{T}{n}{i}{z}{s} ∶ T}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ i ∶ \Nat{∞} \\
      Δ; Γ ⊢ \V{is} ∶ \All{n}{\Stream{v_0}}}
      {Δ; Γ ⊢ \cons{n}{i}{\V{is}} ∶ \Stream{n}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ \V{is} ∶ \Stream{n}}
      {Δ; Γ ⊢ \head{n}{\V{is}} ∶ \Nat{∞}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ \V{is} ∶ \Stream{n} \\ Δ ⊢ m < n}
      {Δ; Γ ⊢ \tail{n}{\V{is}}{m} ∶ \Stream{m}}

    \inferrule{\ctx{Δ}{⋆} ⊢ T \\
      Δ; Γ ⊢ t ∶ \All{⋆}{(\All{v_0}{\sub{T}{\Skip}}) → T} \\ Δ ⊢ n < ⋆}
      {Δ; Γ ⊢ \fix{T}{t}{n} ∶ \sub{T}{\Fill(n)}}
  \end{mathpar}

  \caption{Typing rules for terms}
  \label{fig:typing:terms}
\end{figure}

TODO size substitutions, term substitutions


\section{Operational Semantics}
\label{sec:source:opsem}

TODO