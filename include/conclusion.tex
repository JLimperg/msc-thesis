% CREATED BY DAVID FRISK, 2016
\chapter{Conclusion}
\label{sec:conclusion}

\section{Related Work}
\label{sec:conclusion:related}

\paragraph{Sized Types} Sized types go back to Hughes, Pareto and Sabry
\cite{hughes1996}, who coined the term and introduced the first calculus
featuring sized types. Since then, a variety of calculi have been investigated,
for example by Amadio and Coupet-Grimal \cite{amadio1998}; Barthe, Frade,
Giménez, Pinto and Uustalu \cite{barthe2004}; Blanqui \cite{blanqui2004}; and
Sacchini \cite{sacchiniphd, sacchini2013}. These works all use slightly
different notions of sizes on top of different base calculi (simply typed or
dependently typed, with inductive or coinductive types, etc.), but none of them
address the question of size irrelevance. Agda's particular notion of sized
types, which λST emulates, is due to Abel and Pientka \cite{abel2016}.

\paragraph{Reflexive Graph Models} Reynolds \cite{reynolds1983} first
introduced the technique of interpreting a type as a set together with a
relation on that set. This is usually called a relationally parametric model.
Atkey, Ghani and Johann \cite{atkey2014} apply this technique to a dependent
type theory, showing in particular how families of reflexive graphs can be used
to interpret type dependencies. Vezzosi \cite{vezzosi2015} gives a reflexive
graph model of a type theory with guarded recursion, another type-based
termination checking mechanism. Nuyts, Vezzosi and Devriese \cite{nuyts2017}
present a dependent type theory with parametric quantifiers for which they also
give a reflexive graph model. Their calculus allows users to reason internally
about parametricity, which enables an encoding of sized types as types
parametrically indexed by natural numbers (though they do not discuss the
special size ∞).


\section{Future Work}
\label{sec:conclusion:future}

This thesis is but a first step towards a realistic account of Agda's sized
types. In this section, I discuss some possible directions for future work
(besides the obvious extensions of λST with dependent types, data types and so
forth).


\paragraph{Normalisation}

This thesis is only concerned with one of the two interesting properties of λST,
size irrelevance. The other is normalisation, which is arguably even more
important (but also better covered in related work). In the case of λST, one
would have to be careful with the definition of normalisation since the
inhabitants of $\Stream{∞}$ are infinite by design.


\paragraph{Syntactic Size Irrelevance}

The critical reader will have noticed that this thesis does not, in fact, prove
any interesting properties of λST -- only of its model. To connect the model
with a syntactic notion of size irrelevance, one might proceed as follows:
\begin{enumerate}
  \item Give an operational semantics for λST (easy).
  \item Prove that if two terms are β-equal, their models are equal
    (conceptually easy, but fraught with many technical difficulties).
  \item Give a notion of syntactic equality up to sizes (easy).
  \item Prove a lemma that allows us to conclude syntactic equality up to sizes
    from model-level equality.
\end{enumerate}

I have done much of the work for steps 1--3 already, but did not have time to
complete this line of inquiry. For step 4, it is not clear to me exactly what
lemma we need to connect the model back to the syntax. One candidate is the
following conjecture: For $u ∶ \Nat{m}$ and $u′ ∶ \Nat{m′}$ (in an empty
context), if $u$ and $u′$ are normal and $⟦u⟧ = ⟦u′⟧$ then $u$ and $u′$ are
syntactically equal up to sizes. This, together with the conjecture that
β-equality implies equality in the model, would gives us a relatively weak form
of size irrelevance: If we have $t ∶ \All{n}{\Nat{v_0}}$ and $\sapp{t}{m}$
normalises to $u$ and $\sapp{t}{m′}$ normalises to $u′$ then $u$ and $u′$ are
equal up to sizes.


\paragraph{Infinitely Branching Data Types}

Natural numbers and streams are finitely branching if we look at them as
constructor trees: Each constructor has a finite number of subterms (one or zero
in the case of natural numbers; one in the case of streams). However, Agda and
other dependently typed languages also feature infinitely branching types such
as this one:
\begin{code}
  data ℕTree (A : Set) : Set where
    leaf : A → ℕTree A
    node : (ℕ → ℕTree A) → ℕTree A
\end{code}
\icode{ℕTree~A} is a type of trees similar to rose trees except that each
\icode{node} has countably infinite children.

Such infinitely branching types complicate the interpretation of sizes. Recall
that we interpreted sizes as the height of a constructor tree, a natural number.
For infinitely branching types, however, the height is not computable: The
height of a \icode{node} is one plus the maximum height of its infinite
collection of child trees. This means that we must stop thinking of sizes as
natural numbers and instead think of them as ordinals.

Ordinals present some technical challenges since they are not trivially encoded
in type theory. As part of the work for this thesis, I investigated a particular
subclass of ordinals, the plump ordinals \cite{taylor1996} as presented by
Shulman \cite{shulman2014}, as candidates for a model of sizes. A formalisation
of these ordinals can be found in \icode{Ordinal.\allowbreak Shulman}. However,
the investigation was inconclusive: While the formalisation shows that the plump
ordinals have most of the properties we expect of a model of sizes, they do not
admit the seemingly straightforward lemma that for ordinals $n < m$ and $n′ <
m$, their supremum $n ⊔ n′$ is also less than $m$. More precisely, this lemma is
equivalent to classical logic -- but then again, it is not clear that we need it
to interpret a hypothetical $λST∞$ with infinitely branching types. I
unfortunately did not have time to investigate these issues further.


\section{Conclusion}
\label{sec:conclusion:conclusion}

We have seen a calculus, λST, which approximates Agda's sized types in a
simply-typed setting. This calculus has a model in terms of reflexive graphs
which demonstrates that the sizes of λST are irrelevant. Both λST and the model
are fully formalised.
