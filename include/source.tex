\chapter{Object Language}
\label{sec:source}

We now define λST, the calculus that will be the object of study for the
remainder of this thesis.


\section{Overview}
\label{sec:source:overview}

Before we dive into the technicalities of λST, let me give an overview of the
calculus by example, to show what it is capable of. Those who prefer their
exposition top-down may skip to \secref{source:sizes} and return later.

λST, unlike Agda, does not feature subtyping (though I conjecture that this
could easily be added). To get around this limitation, we first define a
helper function that lifts a sized natural number to a larger size:
\begin{code}
  liftNat : ∀ n < ⋆. ∀ m < n. Nat m → Nat n
  liftNat ≔ Λ n < ⋆. Λ m < n. λ i : Nat m.
              caseNat[Nat n] m i
                (zero n)
                (λ k < m. λ j : Nat k. suc n k j)
\end{code}

\icode{liftNat} already showcases most of the features of λST. Size variables
are introduced at the type level by size quantification \icode{∀ n < m} and at
the term level by the binder \icode{Λ n < m}. Each variable has an upper bound,
here \icode{m}, corresponding to the Agda type \icode{Size<~m}. However, in λST
we do not have \icode{∞~<~∞}, so a variable \icode{n < ∞} cannot be instantiated
with \icode{∞}. Since we do sometimes want to quantify over every size including
\icode{∞}, we introduce the size \icode{⋆} with \icode{∞~<~⋆} so that we can
form the type \icode{∀~n~<~⋆.~T}. This is equivalent to Agda's
\icode{(n~:~Size<~∞) → T}.

λST also features a type of sized natural numbers \icode{Nat~n} with
constructors \icode{zero} and \icode{suc} and eliminator \icode{caseNat[T]}
(where \icode{T} is an arbitrary type). The types of the constructors and
eliminator are those one would get if one were to define sized natural numbers
in Agda:
\begin{code}
  zero     : ∀ n < ⋆. Nat n
  suc      : ∀ n < ⋆. ∀ m < n. Nat m → Nat n
  caseℕ[T] : ∀ n < ⋆. Nat n → T → (∀ m < n. Nat m → T) → T
\end{code}
The \icode{caseNat[T]} eliminator performs case analysis: If its first non-size
argument is zero, it returns the second argument; otherwise it applies the
function given as the third argument to the predecessor of the first argument
(which has a smaller size). Thus, \icode{liftNat} is the identity function up to
sizes: If the input is zero, it returns zero; otherwise it returns the successor
of the input's predecessor.

Using \icode{liftNat}, we define the function \icode{half}, which divides its
input by two (rounding down if the input is odd):
\begin{code}
  half : ∀ n < ⋆. Nat n → Nat n
  half ≔ fix[Nat ∙ → Nat ∙]
          (Λ n < ⋆. λ rec ∶ (∀ m < n. Nat m → Nat m). λ i : Nat n.
            caseNat[Nat n] n i
              (zero n)
              (λ m < n. λ j : Nat m. caseNat[Nat n] m j
                (zero n)
                (λ o < m. λ k : Nat o. liftNat n o (rec o k))))
\end{code}
The definition of \icode{half} is recursive, so we need the centrepiece of λST:
the size-based fixpoint operator \icode{fix} of type
\begin{code}
  fix[T ∙] : (∀ n < ⋆. (∀ m < n. T m) → T n) → ∀ n < ⋆. T n
\end{code}
Here, \icode{T} is an arbitrary type with one free size variable denoted by the
\enquote{hole} \icode{∙}. The type of \icode{fix} corresponds to a recursion
scheme over sizes: If from an element of \icode{T} with size \icode{m} we can
construct an element of \icode{T} with a greater size \icode{n} then we can
construct an element of \icode{T} with any size.

In \icode{half}, we use \icode{fix} to construct a function from \icode{i :
  Nat~n} to \icode{Nat~n}. If \icode{i} is zero, we return zero. Otherwise, we
consider the predecessor \icode{j} of \icode{i}, which has some size \icode{m <
  n}. If \icode{j} is zero, we again return zero. Otherwise, we call the
function \icode{rec} provided by \icode{fix}, which represents a recursive call
of \icode{half}, and apply it to the predecessor of \icode{j} (i.e.\ \icode{i -
  2}). This has size \icode{o}, so we must use \icode{liftNat} to lift it to
size \icode{n}.

Besides natural numbers, the prototypical inductive type, λST also features
the prototypical coinductive type: sized streams (of natural numbers). They have
one constructor, \icode{cons}, which prepends an element to a stream, and two
destructors, \icode{head} and \icode{tail}, which respectively extract the first
element and the rest of a stream. These have the following types, again analogous
to those one would obtain in Agda:
\begin{code}
  cons : ∀ n < ⋆. Nat ∞ → (∀ m < n. Stream m) → Stream n
  head : ∀ n < ⋆. Stream n → Nat ∞
  tail : ∀ n < ⋆. Stream n → ∀ m < n. Stream m
\end{code}

Using these primitives, we can define, for example, the stream of zeros:
\begin{code}
  zeros : ∀ n < ⋆. Stream n
  zeros ≔ fix[Stream ∙]
            (Λ n < ⋆. λ rec : (∀ m < n. Stream m).
              cons (zero ∞) n rec)
\end{code}
Slightly more interestingly, λST also admits the standard mapping function for
streams:
\begin{code}
  map : (Nat ∞ → Nat ∞) → ∀ n < ⋆. Stream n → Stream n
  map ≔ λ f : Nat ∞ → Nat ∞. fix[Stream ∙ → Stream ∙]
          (Λ n < ⋆. λ rec : (Λ m < n. Stream m → Stream m). λ xs : Stream n.
            cons (f (head n xs)) n (Λ m < n. rec m (tail n xs m)))
\end{code}
Note that according to its type, \icode{map} is size-preserving: If we apply it
to a stream with at least \icode{n} defined elements, its result also has at
least \icode{n} defined elements. The same applies to \icode{half}, whose type
indicates that its output is no greater than its input. As we saw with the rose
tree example in \secref{background:sized}, such preservation properties are very
useful.


\section{Sizes}
\label{sec:source:sizes}

In the following sections we define λST. This section corresponds to the Agda
module \texttt{Source.\allowbreak Size} in the formalisation (more details about
which in \chapref{formalisation}).

\Def{Sizes} and \Def{size contexts} are defined by the grammar in
\figref{syntax:sizes}. Size variables are de Bruijn indices; we write $v_x$ for
the x-th variable. The examples in the previous sections instead used named
variables for clarity.

\begin{figure}
  \begin{displaymath}
    \begin{array}{llcll}
      \text{size} & n, m, o & \bnfdef & v_x & \text{(size variable)} \\
      & & | & 0 & \text{(zero)} \\
      & & | & \ssuc{n} & \text{(successor)} \\
      & & | & ∞ & \text{(infinity)} \\
      & & | & ⋆ & \text{(star)} \\

      \text{size context} & Δ, Ω & \bnfdef & () & \text{(empty context)} \\
      & & | & \ctx{Δ}{n} & \text{(context extension)}
    \end{array}
  \end{displaymath}

  \caption{Syntax of sizes, size variables and size contexts}
  \label{fig:syntax:sizes}
\end{figure}

Our size grammar is essentially that of Agda (although of course Agda does not
have a separate grammatical category for sizes). We only add two sizes that
could easily be added to Agda as well: $0$ and $⋆$. Both are needed because λST,
unlike Agda, does not admit the rule $∞ < ∞$. For $⋆$ in particular we will have
$∞ < ⋆$, so a constraint of the form $x < ⋆$ corresponds to the Agda type
\icode{Size<~∞}. Contexts are telescopes of size bounds: In the context
$\ctx{Δ}{n}$, the zeroth variable $v_0$ ranges over sizes less than $n$ and $n$
may involve variables in $Δ$.

The typing judgments for sizes are mutually inductively generated by the rules
in \figref{typing:sizes}. The judgment $Δ ⊢ v_x < n$ holds if $v_x$ is a valid
index into $Δ$ with declared bound $n$. The other two judgments, $Δ ⊢ n$ and $⊢
Δ$, ensure that sizes and contexts, respectively, are scope-safe. In the
definition of $Δ ⊢ v_x < n$, we use a weakened size $\wk(n)$, which is $n$ with
all variables incremented once.
\begin{figure}
  \begin{mathpar}
    \fbox{$Δ ⊢ v_x < n$} \\

    \inferrule{Δ ⊢ n}{\ctx{Δ}{n} ⊢ v_0 < n}

    \inferrule{Δ ⊢ v_x < n \\ Δ ⊢ m}{\ctx{Δ}{m} ⊢ v_{x + 1} < \wk(n)} \\

    \fbox{$Δ ⊢ n$} \\

    \inferrule{Δ ⊢ v_x < n}{Δ ⊢ v_x}

    \inferrule{⊢ Δ}{Δ ⊢ 0 \\ Δ ⊢ ∞ \\ Δ ⊢ ⋆}

    \inferrule{Δ ⊢ n}{Δ ⊢ \ssuc{n}} \\

    \fbox{$⊢ Δ$} \\

    \inferrule{ }{⊢ ()}

    \inferrule{Δ ⊢ n}{⊢ \ctx{Δ}{n}}

  \end{mathpar}

  \caption{Typing rules for sizes and size contexts}
  \label{fig:typing:sizes}
\end{figure}

For convenience, the judgments are defined such that $Δ ⊢ v_x < n$ implies $Δ ⊢
n$ and $Δ ⊢ n$ implies $⊢ Δ$, as is easily proved by induction on the respective
derivation. All other judgments we define below are structured similarly, so for
example $Δ ⊢ T$ (scope-safety of the type $T$) implies $⊢ Δ$ and $Δ; Γ ⊢ t ∶ T$
(well-typedness of a term $t$ of type $T$ in context $Γ$ and size context $Δ$)
implies $Δ ⊢ T$. We will henceforth use these lemmas implicitly.

Next, we define a syntactic comparison relation $Δ ⊢ n < m$ between sizes (in
the same context), which is inductively generated by the rules in
\figref{typing:order}. The rules of $<$ are all supported by the intuition that
sizes are like natural numbers, only extended with ∞ and ⋆. The first rule is
not circular; its premise refers to the judgment $Δ ⊢ v_x < n$ from
\figref{typing:sizes}.

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ ⊢ n < m$} \\

    \inferrule{Δ ⊢ v_x < n}{Δ ⊢ v_x < n}

    \inferrule{Δ ⊢ n < ∞}{Δ ⊢ n < \ssuc{n}}

    \inferrule{⊢ Δ}{Δ ⊢ 0 < ∞}

    \inferrule{Δ ⊢ n < ∞}{Δ ⊢ \ssuc{n} < ∞}

    \inferrule{⊢ Δ}{Δ ⊢ ∞ < ⋆}

    \inferrule{Δ ⊢ n < m \\ Δ ⊢ m < o}{Δ ⊢ n < o}
  \end{mathpar}

  \caption{Size comparison}
  \label{fig:typing:order}
\end{figure}

Our $<$ differs from Agda's in two significant ways. First, Agda admits the rule
$∞ < ∞$ while we do not. This deviation is probably necessary considering that
$∞ < ∞$ seems to be the root cause of multiple inconsistencies in Agda (see
\secref{background:sized}).

Second, we have $n < \ssuc{n}$ only if $n < ∞$ while Agda does not require this
premise. So in particular, we do not admit $∞ < \ssuc{∞}$ or $\ssuc{∞} <
\ssuc{\ssuc{∞}}$. Agda, on the other hand, does admit these rules but also
identifies $∞$ definitionally with $\ssuc{\dots\ssuc{∞}}$, which leads to
another proof of $∞ < ∞$.

In λST, we do not identify $∞$ with $\ssuc{∞}$. However, our definition of $<$
renders sizes of the form $\ssuc{\dots\ssuc{∞}}$ essentially useless: They are
not less than any other size and therefore cannot be used in most situations.
(The same goes for $\ssuc{\dots\ssuc{⋆}}$.) This means that we can get away with
leaving these sizes effectively uninterpreted in the model. We could
alternatively disallow them via the size typing rules, but that would add much
tedious code to the formalisation.

Concluding the discussion of sizes, we state a technical lemma about weakening
that will be needed later:
\begin{lemma}[Weakening preserves typing and $<$]
  \label{lem:wk-preservation}
  If $Δ ⊢ n$ and $Δ ⊢ m$ then $\ctx{Δ}{m} ⊢ \wk(n)$. If $Δ ⊢ o$ and $Δ ⊢ n < m$
  then $\ctx{Δ}{o} ⊢ \wk(n) < \wk(m)$.
\end{lemma}

I do not give a proof of this lemma, and indeed most of the following lemmas,
because both properties are proved by an almost trivial induction. Instead, I
refer the reader to the formalisation (TODO link), which follows the text
closely and provides all the details one could ever wish for.


\section{Size Substitutions}
\label{sec:source:sub}

Having size variables, we must say how to substitute for them. λST uses implicit
substitutions, so substitutions are not part of the calculus' grammar. We do,
however, define a universe of simultaneous substitutions between given size
contexts -- this will be helpful when we get to the model, where substitutions
will correspond to morphisms between (the interpretations of) size contexts.
Size substitutions and their properties are formalised in
\texttt{Source.\allowbreak Size.\allowbreak Substitution.\allowbreak Canonical}.

A \Def{size substitution} is a snoc-list of sizes. We write $()$ for the empty
substitution and $\ssub{σ}{n}$ for the extension of $σ$ with a size $n$. The
application of a substitution to a size, $\sub{n}{σ}$, is defined by recursion
on $n$:
\begin{Align*}
  \sub{v_x}{()} &≔& v_x \\
  \sub{v_0}{\ssub{σ}{n}} &≔& n \\
  \sub{v_{x + 1}}{\ssub{σ}{n}} &≔& \sub{v_x}{σ} \\
  \sub{0}{σ} &≔& 0 \\
  \sub{(\ssuc{n})}{σ} & ≔ & \ssuc{\sub{n}{σ}} \\
  \sub{∞}{σ} &≔& ∞ \\
  \sub{⋆}{σ} &≔& ⋆ \\
\end{Align*}
\figref{typing:ssub} gives the typing rules for size substitutions. The first
equation above is impossible if $σ$ and $n$ are well-typed.

\begin{figure}
  \begin{mathpar}
    \fbox{$σ ∶ Δ ⇒ Ω$} \\

    \inferrule{⊢ Δ}{() ∶ Δ ⇒ ()} \\

    \inferrule{σ ∶ Δ ⇒ Ω \\ Δ ⊢ n \\ Ω ⊢ m \\ Δ ⊢ n < \sub{m}{σ}}{\ssub{σ}{n} ∶ Δ ⇒ \ctx{Ω}{m}}
  \end{mathpar}

  \caption{Typing rules for size substitutions}
  \label{fig:typing:ssub}
\end{figure}

The typing rules ensure that if we have $σ ∶ Δ ⇒ Ω$ then $σ$ maps every variable
$v_x$ in $Ω$ to a size $n$ such that $n$ contains only variables in $Δ$ and $n$
respects the bound declared for $v_x$ in $Ω$. Due to these properties,
well-typed substitutions are well-behaved with regards to typing and size
comparison:

\begin{lemma}[Size substitutions preserve typing and $<$]
  \label{lem:sub-preservation}
  If $σ ∶ Δ ⇒ Ω$ and $Ω ⊢ n$ then $Δ ⊢ \sub{n}{σ}$. If $σ ∶ Δ ⇒ Ω$ and $Ω ⊢ n <
  m$ then $Δ ⊢ \sub{n}{σ} < \sub{m}{σ}$.
\end{lemma}

\begin{proof}
  By induction on the derivation of $Ω ⊢ n$. In the proof of $Δ ⊢ \sub{n}{σ} <
  \sub{m}{σ}$, we use the lemma $\sub{\wk(m)}{\ssub{σ}{n}} = \sub{m}{σ}$, which
  is proved by a simple induction.
\end{proof}

Note that we write $σ ∶ Δ ⇒ Ω$ even though substitution with $σ$ transforms an
object in $Ω$ into an object in $Δ$. This notation is inspired by the model,
where $Δ$ and $Ω$ will be particular types and $σ$ a function between them.

Having constructed a universe of substitutions, we now define some particular
substitutions in this universe which we will use later. We could also have
axiomatised these substitutions directly, but that would have made the
substitution operation and any proofs about it more complex, and we would also
have had to axiomatise some equations between substitutions instead of proving
them as a lemma. Our design leads to some subtle problems in the formalisation;
see \secref{formalisation:sub} for details and a workaround.

We define the following well-typed substitutions (assuming well-typed sizes $Ω ⊢
n$ and $Δ ⊢ m$ as well as substitutions $σ ∶ Δ ⇒ Ω$, $τ ∶ Ω ⇒ Ω′$):
\begin{itemize}
  \item The \Def{weakening} of $σ$ is
    \begin{Align*}
      \multicolumn{3}{l}{\Weaken(σ) ∶ \ctx{Δ}{m} ⇒ Ω} \\
      \Weaken(()) &≔& () \\
      \Weaken(\ssub{σ}{n}) &≔& \ssub{\Weaken(σ)}{\wk(n)}.
    \end{Align*}
  \item The \Def{lifting} of $σ$ is
    \begin{gather*}
      \Lift(σ) ∶ \ctx{Δ}{n[σ]} ⇒ \ctx{Ω}{n} \\
      \Lift(σ) ≔ \ssub{\Weaken(σ)}{v_0}.
    \end{gather*}
   \item The \Def{identity substitution} $\Id_Δ$ is
     \begin{Align*}
       \multicolumn{3}{l}{\Id_Δ ∶ Δ ⇒ Δ} \\
       \Id_{()} &≔& () \\
       \Id_{\ctx{Δ}{n}} &≔& \Lift(\Id_Δ).
     \end{Align*}
   \item The \Def{forward composition} of $σ$ and $τ$ is
     \begin{Align*}
       \multicolumn{3}{l}{σ \fcomp τ ∶ Δ ⇒ Ω′} \\
       σ \fcomp () &≔& () \\
       σ \fcomp (\ssub{τ}{n}) &≔& \ssub{(σ \fcomp τ)}{\sub{n}{σ}}
     \end{Align*}
   \item The \Def{weakening substitution} is
     \begin{gather*}
       \Wk ∶ \ctx{Δ}{m} ⇒ Δ \\
       \Wk ≔ \Weaken(\Id).
     \end{gather*}
   \item Assuming that $Δ ⊢ n < m$, the \Def{filling substitution} of $n$ is
     \begin{gather*}
       \Fill(n) ∶ Δ ⇒ \ctx{Δ}{m} \\
       \Fill(n) ≔ \ssub{\Id_Δ}{n}.
     \end{gather*}
   \item The \Def{skipping substitution} is
     \begin{gather*}
       \Skip ∶ \ctx{\ctx{Δ}{m}}{v_0} ⇒ \ctx{Δ}{m} \\
       \Skip ≔ \ssub{\Weaken(\Wk)}{v_0}.
     \end{gather*}
\end{itemize}

The first five of these substitutions are standard. The filling substitution
$\Fill(n)$ instantiates the zeroth variable with $n$ while leaving everything
else as it is. The skipping substitution is perhaps easier to understand if we
switch to explicit variables for a moment: Given a size $n$ in the context $Δ,\,
x < m$, $\sub{n}{\Skip}$ lives in the context $Δ,\, x < m, y < x$ and all
occurrences of $x$ in $n$ are replaced by $y$. In this sense, $\sub{n}{\Skip}$
\enquote*{skips} $x$.


\section{Types}
\label{sec:source:types}

We move on to the type-level expressions of λST. This section is formalised in
\texttt{Source.\allowbreak Type}.

The types and contexts of λST are generated by the grammar in
\figref{syntax:types}. Their typing rules appear in \figref{typing:types}.

\begin{figure}
  \begin{displaymath}
    \begin{array}{llcll}
      \text{type} & T, U, V & \bnfdef & \Nat{n} & \text{(sized naturals)} \\
      & & | & \Stream{n} & \text{(sized streams)} \\
      & & | & T → U & \text{(function space)} \\
      & & | & \All{n}{T} & \text{(size quantification)} \\

      \text{context} & Γ, Ψ & \bnfdef & () & \text{(empty context)} \\
      & & | & \Ctx{Γ}{T} & \text{(context extension)}\\
    \end{array}
  \end{displaymath}

  \caption{Syntax of types and contexts}
  \label{fig:syntax:types}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ ⊢ T$} \\

    \inferrule{Δ ⊢ n}{Δ ⊢ \Nat{n} \\ Δ ⊢ \Stream{n}}

    \inferrule{Δ ⊢ T \\ Δ ⊢ U}{Δ ⊢ T → U}

    \inferrule{\ctx{Δ}{n} ⊢ T}{Δ ⊢ \All{n}{T}}
    \\

    \fbox{$Δ ⊢ Γ$} \\

    \inferrule{⊢ Δ}{Δ ⊢ ()}

    \inferrule{Δ ⊢ Γ \\ Δ ⊢ T}{Δ ⊢ \ctx{Δ}{T}}
  \end{mathpar}

  \caption{Typing rules for types and contexts}
  \label{fig:typing:types}
\end{figure}

λST features two base types: $\Nat{n}$, the type of sized natural numbers, and
$\Stream{n}$, the type of sized streams. We will discuss these in more detail
when we get to the terms of λST. As for type formers, λST has a non-dependent
function space $T → U$ and size quantification $\All{n}{T}$. Note that $n$ is
not a variable, as the notation may suggest, but the bound of the zeroth de
Bruijn index in $T$. Size quantification works essentially like quantification
in System F if we think of the bound $n$ as the \enquote*{type} of a size
variable. Contexts are lists of types. The typing rules for types and contexts
ensure scope-safety relative to some size context.

Since types can contain size variables, we define \Def{size substitution in
  types}, written $\sub{T}{σ}$, by recursion over the type:
\begin{Align*}
  \sub{(\Nat{n})}{σ} &≔& \Nat{\sub{n}{σ}} \\
  \sub{(\Stream{n})}{σ} &≔& \Stream{\sub{n}{σ}} \\
  \sub{(T → U)}{σ} &≔& \sub{T}{σ} → \sub{U}{σ} \\
  \sub{(\All{n}{T})}{σ} &≔& \All{\sub{n}{σ}}{\sub{T}{\Lift(σ)}}
\end{Align*}
Substitution in contexts $\sub{Γ}{σ}$ is the pointwise extension of substitution
in types.

The only interesting case of the above definition is that for size
quantification. Here, we must recurse with $\Lift(σ)$ rather than $σ$ because
$T$ is a type in $\ctx{Δ}{n}$ while $\All{n}{T}$ is a type in $Δ$. As usual,
size substitution preserves scope safety: If $Ω ⊢ T$ and $σ ∶ Δ ⇒ Ω$ then $Δ ⊢
T$ (and similar for contexts).


\section{Terms}
\label{sec:source:terms}

In this section, we define the terms of λST and their typing rules. The
corresponding module in the formalisation is \texttt{Source.\allowbreak Term}.

The terms of λST are generated by the grammar in \figref{syntax:terms}. Term
variables, like size variables, are de Bruijn indices.

\begin{figure}
  \begin{displaymath}
    \begin{array}{llcll}
      \text{term} & t, u, v & \bnfdef & v_x & \text{(variable)} \\
      & & | & \lam{T}{t} & \text{(abstraction)} \\
      & & | & \app{t}{u} & \text{(application)} \\
      & & | & \slam{n}{t} & \text{(size abstraction)} \\
      & & | & \sapp{t}{n} & \text{(size application)} \\
      & & | & \zero{n} & \text{(zero)} \\
      & & | & \suc{n}{m}{t} & \text{(successor)} \\
      & & | & \case{T}{n}{t}{u}{v} & \text{(case analysis for $\Nat{n}$)} \\
      & & | & \cons{t}{n}{u} & \text{(stream construction)} \\
      & & | & \head{n}{t} & \text{(stream head)} \\
      & & | & \tail{n}{t}{m} & \text{(stream tail)} \\
      & & | & \fix{T}{t}{n} & \text{(sized fixpoint)}
    \end{array}
  \end{displaymath}

  \caption{Syntax of terms}
  \label{fig:syntax:terms}
\end{figure}

The first three term constructions are those of the simply-typed lambda
calculus: variables, abstraction and application. The next two are size
abstraction and size application, which respectively introduce and eliminate a
size quantification. They are analogous to System F's type abstraction and type
application.

The other terms are conceptually constants, though we introduce them as term
formers to simplify the model (and particularly the formalisation). If they were
constants, they would have the following types (with explicit variables for
convenience):
\begin{Align*}
  \mathrm{zero} &∶& \AllE{x}{⋆}{\Nat{x}} \\
  \mathrm{suc} &∶& \AllE{x}{⋆}{\AllE{y}{x}{\Nat{y} → \Nat{x}}} \\
  \mathrm{caseNat}[T] &∶& \AllE{x}{⋆}{\Nat{x} → T → (\AllE{y}{x}{T}) → T} \\
  \mathrm{cons} &∶& \Nat{∞} → \AllE{x}{⋆}{(\AllE{y}{x}{\Stream{y}}) → \Stream{x}} \\
  \mathrm{head} &:& \AllE{x}{⋆}{\Stream{x} → \Nat{∞}} \\
  \mathrm{tail} &:& \AllE{x}{⋆}{\Stream{x} → \AllE{y}{x}{\Stream{y}}} \\
  \mathrm{fix}[T(∙)] &:& (\AllE{x}{⋆}{(\AllE{y}{x}{T(y)}) → T(x)}) → \AllE{x}{⋆}{T(x)}
\end{Align*}
The terms $\mathrm{zero}$ and $\mathrm{suc}$ serve as constructors of $\Nat{n}$.
The type $\Nat{n}$ may be thought of as the set of natural numbers less than or
equal to $n$. As such, 0 is a member of $\Nat{n}$ for any $n$, as the type of
$\mathrm{zero}$ indicates. Similarly, if we have a natural number $≤ n$, its
successor is $≤ m$ for any $m > n$, which justifies the type of $\mathrm{suc}$.
The eliminator for $\Nat{n}$ into some arbitrary type $T$ is
$\mathrm{caseNat}[T]$; it performs case analysis on its first non-size argument.
In the zero case, it returns its second argument while in the successor case, it
returns the result of applying the function given as the third argument to the
predecessor of the given natural. That predecessor, of course, has some smaller
size $m < n$.

For $\Stream{n}$, the size $n$ has the opposite meaning: Where $\Nat{n}$
contains naturals up to \emph{at most} $n$, $\Stream{n}$ is roughly speaking the
type of lists of naturals with \emph{at least} $n$ elements. This is because
$\Nat{n}$ is an inductive type while $\Stream{n}$ is coinductive. More
precisely, a value of $\Stream{n}$ is a function which maps any natural number
$m ≤ n$ to a natural number. $\Stream{∞}$ is then the type of functions $ℕ → ℕ$,
which is isomorphic to the coinductively defined type of infinite streams of
naturals.

The constructor $\mathrm{cons}$ and the destructors $\mathrm{head}$ and
$\mathrm{tail}$ reflect this understanding. The first destructor,
$\mathrm{head}$, extracts the element at index 0 from a $\Stream{n}$ (which
always exists since $0 ≤ n$). The second destructor, $\mathrm{tail}$, when given
a $\Stream{n}$, returns its tail, which has one less element and is therefore an
element of $\Stream{m}$ for any $m < n$. The constructor $\mathrm{cons}$ takes a
function which generates a $\Stream{m}$ for any $m < n$ and prepends an element,
returning a bigger $\Stream{n}$.\footnote{Another plausible type for
  $\mathrm{cons}$ would be $\Nat{∞} → \AllE{x}{⋆}{\AllE{y}{x}{\Stream{y} →
      \Stream{x}}}$, where the stream argument is a single stream instead of a
  family. I choose not to use this simpler type because if we define sized
  streams in Agda, $\mathrm{cons}$ has the type from the main text.}

The final term, $\mathrm{fix}[T]$, is at the heart of λST: It is a size-based
fixpoint combinator that allows us both to recurse over sized natural numbers
and to build sized streams corecursively. It is parameterised by a type $T$ with
one free size variable or \enquote*{hole}, as the notation $T(∙)$ suggests.
The type of $\mathrm{fix}[T]$ is essentially the principle of induction over
sizes: If from an object of size $m$ we can construct an object of size $n > m$,
then we can construct an object of any size.

The typing rules of λST terms, which appear in \figref{typing:terms}, follow
directly from the previous discussion, only with constants replaced by
equivalent term formers and explicit variables replaced by de Bruijn indices and
size substitutions.

\begin{figure}
  \begin{mathpar}
    \fbox{$Δ; Γ ⊢ t ∶ T$} \\

    \inferrule{Δ ⊢ Γ \\ Δ ⊢ T}{Δ; \Ctx{Γ}{T} ⊢ v_0 ∶ T}

    \inferrule{Δ; Γ ⊢ v_x ∶ T \\ Δ ⊢ U}{Δ; \Ctx{Γ}{U} ⊢ v_{x + 1} ∶ T}

    \inferrule{Δ; \Ctx{Γ}{T} ⊢ t ∶ U}{Δ; Γ ⊢ \lam{T}{t} ∶ T → U}

    \inferrule{Δ; Γ ⊢ t ∶ T → U \\ Δ; Γ ⊢ u ∶ T}{Δ; Γ ⊢ \app{t}{u} ∶ U}

    \inferrule{\ctx{Δ}{n}; \sub{Γ}{\Wk} ⊢ t ∶ T \\ Δ ⊢ Γ}
      {Δ; Γ ⊢ \slam{n}{t} ∶ \All{n}{T}}

    \inferrule{Δ; Γ ⊢ t ∶ \All{n}{T} \\ Δ ⊢ m < n}
      {Δ; Γ ⊢ \sapp{t}{m} ∶ \sub{T}{\Fill(m)}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ ⊢ Γ}{Δ; Γ ⊢ \zero{n} ∶ \Nat{n}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ ⊢ m < n \\ Δ; Γ ⊢ i ∶ \Nat{m}}
      {Δ; Γ ⊢ \suc{n}{m}{i} ∶ \Nat{n}}

    \inferrule{Δ ⊢ T \\ Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ i ∶ \Nat{n} \\ Δ; Γ ⊢ z ∶ T \\
      Δ; Γ ⊢ s ∶ \All{n}{\Nat{v_0} → \sub{T}{\Wk}}}
      {Δ; Γ ⊢ \case{T}{n}{i}{z}{s} ∶ T}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ i ∶ \Nat{∞} \\
      Δ; Γ ⊢ \V{is} ∶ \All{n}{\Stream{v_0}}}
      {Δ; Γ ⊢ \cons{n}{i}{\V{is}} ∶ \Stream{n}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ \V{is} ∶ \Stream{n}}
      {Δ; Γ ⊢ \head{n}{\V{is}} ∶ \Nat{∞}}

    \inferrule{Δ ⊢ n < ⋆ \\ Δ; Γ ⊢ \V{is} ∶ \Stream{n} \\ Δ ⊢ m < n}
      {Δ; Γ ⊢ \tail{n}{\V{is}}{m} ∶ \Stream{m}}

    \inferrule{\ctx{Δ}{⋆} ⊢ T \\
      Δ; Γ ⊢ t ∶ \All{⋆}{(\All{v_0}{\sub{T}{\Skip}}) → T} \\ Δ ⊢ n < ⋆}
      {Δ; Γ ⊢ \fix{T}{t}{n} ∶ \sub{T}{\Fill(n)}}
  \end{mathpar}

  \caption{Typing rules for terms}
  \label{fig:typing:terms}
\end{figure}